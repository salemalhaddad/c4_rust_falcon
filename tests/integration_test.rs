use c4_rust::lexer::Lexer;
use c4_rust::parser::{Parser, symbol_table::{SymbolTable, Class}, types::Type};
use c4_rust::codegen::{CodeGenerator, Opcode};
use c4_rust::vm::VM;

#[test]
fn test_simple_add_function() {
    // Simple C program with the add function as main
    let source = r#"
    int main() {
        return add(3, 4);
    }
    
    int add(int a, int b) {
        return a + b;
    }
    "#;

    println!("\n=== Simple Add Function Test ===");
    println!("\n=== Source Code ===");
    println!("{}", source);

    // Initialize the parser with the source code
    let mut parser = Parser::new(source.as_bytes());
    
    // Parse the program and generate code
    let result = parser.parse();
    assert!(result.is_ok(), "Failed to parse program: {:?}", result.err());
    
    // Get the generated bytecode and data
    let (bytecode, data) = result.unwrap();
    
    // Verify bytecode generation
    assert!(!bytecode.is_empty(), "No bytecode was generated");
    
    // Verify that the bytecode contains the ADD instruction
    let contains_add = bytecode.iter().any(|&op| op == Opcode::ADD as i32);
    assert!(contains_add, "Bytecode does not contain ADD instruction");
    
    // Print the generated bytecode and data for debugging
    println!("\n=== Compilation Result ===");
    println!("Test passed! Bytecode contains ADD instruction.");
    
    print_bytecode_and_data(&bytecode, &data);
    
    // Test VM execution with direct bytecode
    test_vm_add_operation();
}

#[test]
fn test_conditional_statements() {
    // C program with conditional statements - using a simple ternary operator
    let source = r#"
    int main() {
        return test_conditional(1);
    }
    
    int test_conditional(int condition) {
        return condition ? 42 : 0;
    }
    "#;

    println!("\n=== Conditional Statements Test ===");
    println!("\n=== Source Code ===");
    println!("{}", source);

    // Initialize the parser with the source code
    let mut parser = Parser::new(source.as_bytes());
    
    // Parse the program and generate code
    let result = parser.parse();
    assert!(result.is_ok(), "Failed to parse program: {:?}", result.err());
    
    // Get the generated bytecode and data
    let (bytecode, data) = result.unwrap();
    
    // Verify bytecode generation
    assert!(!bytecode.is_empty(), "No bytecode was generated");
    
    // Verify that the bytecode contains conditional jump instructions
    let contains_conditional = bytecode.iter().any(|&op| 
        op == Opcode::BZ as i32 || op == Opcode::BNZ as i32);
    assert!(contains_conditional, "Bytecode does not contain conditional instructions");
    
    println!("\n=== Compilation Result ===");
    println!("Test passed! Bytecode contains conditional instructions.");
    
    print_bytecode_and_data(&bytecode, &data);
}

#[test]
fn test_loop_statements() {
    // C program with a simple loop
    let source = r#"
    int main() {
        return test_loop(5);
    }
    
    int test_loop(int count) {
        int sum;
        sum = 0;
        while (count > 0) {
            sum = sum + count;
            count = count - 1;
        }
        return sum;
    }
    "#;

    println!("\n=== Loop Statements Test ===");
    println!("\n=== Source Code ===");
    println!("{}", source);

    // Initialize the parser with the source code
    let mut parser = Parser::new(source.as_bytes());
    
    // Parse the program and generate code
    let result = parser.parse();
    assert!(result.is_ok(), "Failed to parse program: {:?}", result.err());
    
    // Get the generated bytecode and data
    let (bytecode, data) = result.unwrap();
    
    // Verify bytecode generation
    assert!(!bytecode.is_empty(), "No bytecode was generated");
    
    // Verify that the bytecode contains loop-related instructions
    let contains_loop = bytecode.iter().any(|&op| 
        op == Opcode::JMP as i32 || op == Opcode::BZ as i32 || op == Opcode::BNZ as i32);
    assert!(contains_loop, "Bytecode does not contain loop instructions");
    
    println!("\n=== Compilation Result ===");
    println!("Test passed! Bytecode contains loop instructions.");
    
    print_bytecode_and_data(&bytecode, &data);
}

// Helper function to print bytecode and data
fn print_bytecode_and_data(bytecode: &[i32], data: &[u8]) {
    println!("\n=== Bytecode Dump ===");
    for (i, op) in bytecode.iter().enumerate() {
        let opcode = match *op {
            op if op == Opcode::ADD as i32 => "ADD",
            op if op == Opcode::SUB as i32 => "SUB",
            op if op == Opcode::MUL as i32 => "MUL",
            op if op == Opcode::DIV as i32 => "DIV",
            op if op == Opcode::JMP as i32 => "JMP",
            op if op == Opcode::JSR as i32 => "JSR",
            op if op == Opcode::BZ as i32 => "BZ",
            op if op == Opcode::BNZ as i32 => "BNZ",
            op if op == Opcode::ENT as i32 => "ENT",
            op if op == Opcode::LEV as i32 => "LEV",
            op if op == Opcode::LI as i32 => "LI",
            op if op == Opcode::LC as i32 => "LC",
            op if op == Opcode::SI as i32 => "SI",
            op if op == Opcode::SC as i32 => "SC",
            op if op == Opcode::PSH as i32 => "PSH",
            op if op == Opcode::OR as i32 => "OR",
            op if op == Opcode::XOR as i32 => "XOR",
            op if op == Opcode::AND as i32 => "AND",
            op if op == Opcode::EQ as i32 => "EQ",
            op if op == Opcode::NE as i32 => "NE",
            op if op == Opcode::LT as i32 => "LT",
            op if op == Opcode::GT as i32 => "GT",
            op if op == Opcode::LE as i32 => "LE",
            op if op == Opcode::GE as i32 => "GE",
            op if op == Opcode::SHL as i32 => "SHL",
            op if op == Opcode::SHR as i32 => "SHR",
            op if op == Opcode::MOD as i32 => "MOD",
            op if op == Opcode::OPEN as i32 => "OPEN",
            op if op == Opcode::READ as i32 => "READ",
            op if op == Opcode::CLOS as i32 => "CLOS",
            op if op == Opcode::PRTF as i32 => "PRTF",
            op if op == Opcode::MALC as i32 => "MALC",
            op if op == Opcode::FREE as i32 => "FREE",
            op if op == Opcode::MSET as i32 => "MSET",
            op if op == Opcode::MCMP as i32 => "MCMP",
            op if op == Opcode::EXIT as i32 => "EXIT",
            _ => "IMM",
        };
        println!("[{:04}] {}: {}", i, opcode, op);
    }
    
    println!("\n=== Data Segment ===");
    println!("Size: {} bytes", data.len());
    if !data.is_empty() {
        for (i, chunk) in data.chunks(16).enumerate() {
            print!("{:04x}: ", i * 16);
            for b in chunk {
                print!("{:02x} ", b);
            }
            print!("  ");
            for b in chunk {
                if *b >= 32 && *b <= 126 {
                    print!("{}", *b as char);
                } else {
                    print!(".");
                }
            }
            println!();
        }
    } else {
        println!("<empty>");
    }
}

// Helper function to test VM with a direct bytecode for addition
fn test_vm_add_operation() {
    println!("\n=== VM Direct Testing ===");
    
    // Create a simple bytecode that just adds two numbers and exits
    let test_bytecode = vec![
        // IMM 5 - Load immediate value 5 into ax
        Opcode::IMM as i32, 5,
        // PSH - Push ax onto the stack
        Opcode::PSH as i32,
        // IMM 7 - Load immediate value 7 into ax
        Opcode::IMM as i32, 7,
        // ADD - Add the top of stack to ax
        Opcode::ADD as i32,
        // EXIT - Exit with ax as the return value
        Opcode::EXIT as i32
    ];
    
    println!("Test bytecode: {:?}", test_bytecode);
    
    // Create a VM instance with our custom bytecode
    let stack_size = 1024; // 1KB stack
    let debug = true;      // Enable debug output
    let mut vm = VM::new(test_bytecode, vec![], stack_size, debug);
    
    // Execute the VM
    match vm.run() {
        Ok(result) => {
            println!("\nVM execution result: {}", result);
            assert_eq!(result, 12, "5 + 7 should equal 12");
            println!("VM test passed! 5 + 7 = {}", result);
        },
        Err(e) => {
            println!("VM execution error: {}", e);
            panic!("VM execution failed: {}", e);
        }
    }
}


